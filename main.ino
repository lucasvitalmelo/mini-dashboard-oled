#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <EEPROM.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define OLED_ADDR 0x3C

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

const unsigned char bitmap_celta_pixel [] PROGMEM = {
	// 'celta pixel, 128x32px
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xff, 0x03, 0xff, 0xff, 0xe1, 0xf8, 0x01, 0xff, 0xff, 0xfc, 0x00, 0xc0, 0x00, 
	0x00, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xe1, 0xf8, 0x01, 0xff, 0xff, 0xfc, 0x03, 0xf0, 0x00, 
	0x01, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xc1, 0xf0, 0x01, 0xff, 0xff, 0xfc, 0x07, 0xf8, 0x00, 
	0x01, 0xff, 0x00, 0x1c, 0x1f, 0xe0, 0x03, 0x83, 0xf0, 0x00, 0x01, 0xf8, 0x1c, 0x0f, 0xf8, 0x00, 
	0x03, 0xf0, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xf0, 0x00, 0x01, 0xf8, 0x00, 0x1f, 0xfc, 0x00, 
	0x03, 0xe0, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x01, 0xf8, 0x00, 0x39, 0xfc, 0x00, 
	0x07, 0xe0, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x03, 0xf8, 0x00, 0x70, 0xfc, 0x00, 
	0x07, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x07, 0xe0, 0x00, 0x03, 0xf0, 0x00, 0xe0, 0xfc, 0x00, 
	0x07, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x07, 0xe0, 0x00, 0x03, 0xf0, 0x01, 0xc0, 0xfe, 0x00, 
	0x07, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xfc, 0x07, 0xc0, 0x00, 0x03, 0xf0, 0x03, 0x80, 0xfe, 0x00, 
	0x07, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xfc, 0x07, 0xc0, 0x00, 0x03, 0xf0, 0x07, 0x80, 0xfe, 0x00, 
	0x07, 0xe0, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x07, 0xf0, 0x0f, 0x00, 0x7e, 0x00, 
	0x07, 0xe0, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x07, 0xe0, 0x1e, 0x00, 0x7e, 0x00, 
	0x03, 0xf0, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x0f, 0xe0, 0x00, 0x07, 0xe0, 0x3e, 0x00, 0x7e, 0x00, 
	0x03, 0xf8, 0x00, 0x00, 0x3f, 0xc0, 0x03, 0x0f, 0xf0, 0x00, 0x4f, 0xe0, 0x3c, 0x00, 0x7e, 0x00, 
	0x01, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0x07, 0xff, 0xff, 0xcf, 0xe0, 0x78, 0x00, 0x7f, 0x00, 
	0x00, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xcf, 0xe0, 0xf8, 0x00, 0x7f, 0x00, 
	0x00, 0x7f, 0xff, 0xf0, 0x07, 0xff, 0xfe, 0x01, 0xff, 0xff, 0x9f, 0xe1, 0xf0, 0x00, 0x7f, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// === Global variables ===
int brightness = 20;
int currentMenu = 0;
const int totalMenus = 3;
const int tempSensorPin = A0;
const int ledPwmPin = 3;

bool isEditing = false;
bool buttonPressed = false;
unsigned long buttonPressStart = 0;
const unsigned long longPressTime = 3000;

int lastBrightness = brightness;
unsigned long lastChangeTime = 0;
bool brightnessSaved = true;
const int EEPROM_ADDR = 0;

// === Média Móvel ===
const int numReadings = 10;
int readings[numReadings];
int readIndex = 0;
long total = 0;
int average = 0;

const int touchPin = A3;
unsigned long lastPress = 0;
const unsigned long debounce = 50;

void setup() {
  Serial.begin(9600);
  display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);
  display.clearDisplay();

  splashScreen();

  display.setTextColor(SSD1306_WHITE);

  brightness = EEPROM.read(EEPROM_ADDR);
  brightness = constrain(brightness, 0, 100);

  pinMode(touchPin, INPUT);
  pinMode(ledPwmPin, OUTPUT);

  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0;
  }

  Serial.print(EEPROM.read(0));
}

void loop() {
  updateMenu();
  updateMenuButton();
  changeBrightness();
}

void splashScreen() {
  display.drawBitmap(0, 0, bitmap_celta_pixel, 128, 32, WHITE);
  display.display();
  
  delay(2000);
}

void updateMenu() {
  display.clearDisplay();
  switch (currentMenu) {
    case 0: showTemperature(); break;
    case 1: showBrightness(); break;
    case 2: showAbout(); break;
  }
  display.display();
}

void updateMenuButton() {
  static bool lastState = LOW;
  bool state = digitalRead(touchPin);
  unsigned long now = millis();
  const unsigned long debounce = 100; // Aumentado para maior estabilidade

  // Detecta a pressão do botão (transição de LOW para HIGH)
  if (lastState == LOW && state == HIGH && now - lastPress > debounce) {
    buttonPressStart = now;
    lastPress = now;
    buttonPressed = true;
    Serial.println("Botão pressionado (HIGH)");
  }

  // Durante a pressão, verifica toque longo
  if (buttonPressed && state == HIGH && currentMenu == 1) {
    unsigned long pressDuration = now - buttonPressStart;
    if (pressDuration >= longPressTime && !isEditing) {
      isEditing = true;
      buttonPressed = false; // Evita múltiplas ativações
      Serial.println("Entrou no modo de edição");
    } else if (pressDuration >= longPressTime && isEditing) {
      isEditing = false;
      buttonPressed = false;
      Serial.println("Saiu do modo de edição");
    }
  }

  // Detecta a liberação do botão (transição de HIGH para LOW)
  if (lastState == HIGH && state == LOW && now - lastPress > debounce) {
    lastPress = now;
    if (buttonPressed) {
      unsigned long pressDuration = now - buttonPressStart;
      buttonPressed = false;

      // Processa apenas toques curtos (< 3 segundos)
      if (pressDuration < longPressTime && pressDuration > debounce) {
        if (!isEditing) {
          // Navega entre os menus
          currentMenu = (currentMenu + 1) % totalMenus;
          Serial.print("Menu atual: ");
          Serial.println(currentMenu);
        } else if (currentMenu == 1) {
          // Ajusta o brilho no modo de edição
          brightness += 5;
          if (brightness > 100) brightness = 0;
          lastBrightness = brightness;
          lastChangeTime = now;
          brightnessSaved = false;
          Serial.print("Brilho ajustado: ");
          Serial.println(brightness);
        }
      }
    }
    Serial.println("Botão liberado (LOW)");
  }

  lastState = state;
}

void saveBrightnessValue() {
  if (EEPROM.read(EEPROM_ADDR) != brightness) {
    EEPROM.write(EEPROM_ADDR, brightness);

    blinkText("Saved!", 3, 500);
    currentMenu = 0;
    isEditing = false;
  }
}

void changeBrightness() {
  if (brightness != lastBrightness) {
    lastBrightness = brightness;
    lastChangeTime = millis();
    brightnessSaved = false;
  }

  if (!brightnessSaved && millis() - lastChangeTime > 3000) {
    saveBrightnessValue();
    brightnessSaved = true;
  }

  analogWrite(ledPwmPin, map(brightness, 0, 100, 0, 255));
}

void showTemperature() {
  total = total - readings[readIndex];

  int analogValue = analogRead(tempSensorPin);
  readings[readIndex] = analogValue;
  total = total + analogValue;
  readIndex = (readIndex + 1) % numReadings;

  average = total / numReadings;
  float voltage = average * (5.0 / 1023.0);
  float temperatureC = voltage * 100.0;

  display.setTextSize(2);
  String text = String(temperatureC, 1) + " " + (char)247 + "C";

  if (temperatureC >= 99 ) {
    display.invertDisplay(true);
    delay(500);
    display.invertDisplay(false);
  }

  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(text, 0, 0, &x1, &y1, &w, &h);
  int posX = (SCREEN_WIDTH - w) / 2;
  int posY = (SCREEN_HEIGHT - h) / 2;

  display.setCursor(posX, posY);
  display.println(text);

  display.setTextSize(1);
  display.setCursor(0, SCREEN_HEIGHT - 8);

  delay(500);
}

void showBrightness() {
  display.setTextSize(1);

  if (isEditing) {
    display.setCursor(110, 0);
    display.println("Ed.");
  }

  display.setCursor((SCREEN_WIDTH - 30) / 2, 0);
  display.println("Light");

  display.setCursor((SCREEN_WIDTH - 15) / 2, 12);

  String brightnessValue = String(brightness) + '%';
  display.println(brightnessValue);

  int barHeight = 8;
  int barY = SCREEN_HEIGHT - 10 - barHeight;
  int barX = 0;
  int barWidthMax = SCREEN_WIDTH;
  int barWidth = map(brightness, 0, 100, 0, barWidthMax);

  // Draw progress
  display.fillRect(barX, barY + 10, barWidth, barHeight, SSD1306_WHITE);
  display.drawLine(0, SCREEN_HEIGHT, 0, SCREEN_HEIGHT - 10, SSD1306_WHITE);
  display.drawLine(SCREEN_WIDTH / 2, SCREEN_HEIGHT, SCREEN_WIDTH / 2, SCREEN_HEIGHT - 5, SSD1306_WHITE);
  display.drawLine(SCREEN_WIDTH - 1, SCREEN_HEIGHT, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 10, SSD1306_WHITE);

  analogWrite(ledPwmPin, map(brightness, 0, 100, 0, 255));
}

void showAbout() {
  String text = "by: Lucas Vital";

  int16_t x, y;
  uint16_t w, h;
  display.getTextBounds(text, 0, 0, &x, &y, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, (SCREEN_HEIGHT - h) / 2);
  display.println(text);
}

void blinkText(String text, int times, int delayTime) {
  int16_t x, y;
  uint16_t w, h;
  
  display.getTextBounds(text, 0, 0, &x, &y, &w, &h);

  for (int i = 0; i < times; i++) {
    // Mostra o texto
    display.clearDisplay();
    display.setCursor((SCREEN_WIDTH - w) / 2, (SCREEN_HEIGHT - h) / 2);
    display.println(text);
    display.display();
    delay(delayTime);

    // Apaga o texto
    display.clearDisplay();
    display.display();
    delay(delayTime);
  }
}